import 'module-alias/register';
import dotenv from 'dotenv';
dotenv.config();

import express, { Application, Request, Response, NextFunction } from 'express';
import helmet from 'helmet';
import rateLimit from 'express-rate-limit';
import fs from 'fs';
import path from 'path';
import next from 'next';

// Import des routes API
import authRoutes from './routes/auth.routes';
import projectRoutes from './routes/projects.routes';
import categoryRoutes from './routes/category.routes';
import skillRoutes from './routes/skills.routes';
import experienceRoutes from './routes/experience.routes';
import educationRoutes from './routes/education.routes';
import contactRoutes from './routes/contact.routes';
import blogRoutes from './routes/blog.routes';
import githubRoutes from './routes/github.routes';

// Import des middlewares
import { errorHandler } from './middleware/errorHandler';
import { notFound } from './middleware/notFound';
import { requestLogger } from './middleware/logger';
import { prisma } from './config/prisma';
import { corsMiddleware } from './middleware/cors';



class Server {
    private app: Application;
    private port: string | number;
    private nextApp: any;
    private handle: any;

    constructor() {
        this.app = express();
        this.port = process.env.PORT || 3001;
        
        // Initialiser Next.js seulement en production pour √©viter les probl√®mes de dev
        if (process.env.NODE_ENV === 'production') {
            const nextConfig = {
                distDir: 'build',
                trailingSlash: false,
                generateEtags: false,
                poweredByHeader: false
            };
            
            this.nextApp = next({ 
                dev: false, 
                dir: process.cwd(),
                conf: nextConfig
            });
            this.handle = this.nextApp.getRequestHandler();
        }
    }

    private async initializeNext(): Promise<void> {
        // Initialiser Next.js seulement en production
        if (process.env.NODE_ENV === 'production' && this.nextApp) {
            try {
                // V√©rifier que le dossier build existe
                const buildPath = path.join(process.cwd(), 'build');
                console.log(`üîç V√©rification du dossier build: ${buildPath}`);
                
                // Lister le contenu du dossier racine
                console.log('üìÅ Contenu du dossier racine:');
                fs.readdirSync(process.cwd()).forEach((file: string) => {
                    console.log(`  - ${file}`);
                });
                
                // V√©rifier si le dossier build existe
                if (fs.existsSync(buildPath)) {
                    console.log('‚úÖ Dossier build trouv√©');
                    console.log('üìÅ Contenu du dossier build:');
                    fs.readdirSync(buildPath).forEach((file: string) => {
                        const filePath = path.join(buildPath, file);
                        const stat = fs.statSync(filePath);
                        if (stat.isDirectory()) {
                            console.log(`  üìÅ ${file}/`);
                            // Lister quelques fichiers dans les sous-dossiers importants
                            if (['server', 'static'].includes(file)) {
                                try {
                                    const subFiles = fs.readdirSync(filePath).slice(0, 5);
                                    subFiles.forEach(subFile => {
                                        console.log(`    - ${subFile}`);
                                    });
                                    if (fs.readdirSync(filePath).length > 5) {
                                        console.log(`    ... et ${fs.readdirSync(filePath).length - 5} autres fichiers`);
                                    }
                                } catch (e) {
                                    console.log(`    (erreur lecture sous-dossier: ${e})`);
                                }
                            }
                        } else {
                            console.log(`  üìÑ ${file}`);
                        }
                    });
                    
                    // V√©rifications sp√©cifiques Next.js
                    const buildManifestPath = path.join(buildPath, 'build-manifest.json');
                    const pagesManifestPath = path.join(buildPath, 'server', 'pages-manifest.json');
                    
                    console.log(`üîç Build manifest: ${fs.existsSync(buildManifestPath) ? '‚úÖ' : '‚ùå'}`);
                    console.log(`üîç Pages manifest: ${fs.existsSync(pagesManifestPath) ? '‚úÖ' : '‚ùå'}`);
                    
                } else {
                    console.log('‚ùå Dossier build non trouv√©');
                }
                
                await this.nextApp.prepare();
                console.log('‚úÖ Next.js app pr√©par√©e avec succ√®s');
            } catch (error) {
                console.error('‚ùå Erreur lors de la pr√©paration de Next.js:', error);
                throw error;
            }
        } else {
            console.log('‚ÑπÔ∏è Next.js d√©sactiv√© en d√©veloppement');
        }
    }

    private initializeMiddlewares(): void {
        // S√©curit√© avec Helmet
        this.app.use(helmet({
            contentSecurityPolicy: false,
            crossOriginEmbedderPolicy: false,
        }));

        // Cors pour les requ√™tes cross-origin
        this.app.use(corsMiddleware);

        // Rate limiting
        const limiter = rateLimit({
            windowMs: 15 * 60 * 1000,
            max: 150,
            message: {
                error: 'Trop de requ√™tes depuis cette IP, veuillez r√©essayer plus tard.'
            },
            standardHeaders: true,
            legacyHeaders: false,
        });

        const authLimiter = rateLimit({
            windowMs: 15 * 60 * 1000,
            max: 30,
            skipSuccessfulRequests: true,
        });

        this.app.use('/api/', limiter);
        this.app.use('/api/auth', authLimiter);

        // Parsing des requ√™tes
        this.app.use(express.json({ limit: '10mb' }));
        this.app.use(express.urlencoded({ extended: true, limit: '10mb' }));

        // Logger des requ√™tes (en d√©veloppement)
        if (process.env.NODE_ENV === 'development') {
            this.app.use(requestLogger);
        }

        // Health check
        this.app.get('/health', (req: Request, res: Response) => {
            res.status(200).json({
                success: 'OK',
                timestamp: new Date().toISOString(),
                uptime: process.uptime(),
                environment: process.env.NODE_ENV,
            });
        });
    }

    private initializeRoutes(): void {
        // Routes API - IMPORTANT: Avant Next.js handler
        this.app.use('/api/auth', authRoutes);
        this.app.use('/api/projects', projectRoutes);
        this.app.use('/api/categories', categoryRoutes);
        this.app.use('/api/skills', skillRoutes);
        this.app.use('/api/experiences', experienceRoutes);
        this.app.use('/api/educations', educationRoutes);
        this.app.use('/api/contacts', contactRoutes);
        this.app.use('/api/blog', blogRoutes);
        this.app.use('/api/github', githubRoutes);
    }

    private initializeStaticServing(): void {
        // Servir les uploads
        this.app.use('/uploads', express.static(path.join(process.cwd(), 'uploads')));

        // CORRECTION: Servir les assets Next.js depuis build/static
        this.app.use('/_next/static', express.static(path.join(process.cwd(), 'build', 'static'), {
            setHeaders: (res, filePath) => {
                console.log(`üì¶ Next.js asset: ${filePath}`);
                if (filePath.match(/\.(js|css|woff2?|ttf|eot)$/)) {
                    res.setHeader('Cache-Control', 'public, max-age=31536000, immutable');
                }
            }
        }));

        // Servir les autres fichiers statiques
        this.app.use('/static', express.static(path.join(process.cwd(), 'build', 'static'), {
            setHeaders: (res, filePath) => {
                console.log(`üì¶ Static file: ${filePath}`);
                if (filePath.match(/\.(png|jpg|jpeg|gif|ico|svg|webp)$/)) {
                    res.setHeader('Cache-Control', 'public, max-age=86400');
                }
            }
        }));
    }

    private initializeNextJsHandling(): void {
        // Utiliser le handler Next.js seulement en production
        if (process.env.NODE_ENV === 'production' && this.handle) {
            // Toutes les routes qui ne sont pas des API ou des fichiers statiques
            this.app.get('/{*any}', async (req: Request, res: Response, next) => {
                // Exclure les routes API et les fichiers statiques
                if (req.path.startsWith('/api/') || 
                    req.path.startsWith('/uploads/') || 
                    req.path.startsWith('/_next/') ||
                    req.path.startsWith('/static/') ||
                    req.path === '/health') {
                    return next();
                }
                
                try {
                    console.log(`üîÑ Next.js handling: ${req.method} ${req.path}`);
                    await this.handle!(req, res);
                } catch (error) {
                    console.error('‚ùå Next.js handler error:', error);
                    // Fallback vers une page d'index statique
                    const indexPath = path.join(process.cwd(), 'build', 'index.html');
                    if (req.path === '/' && require('fs').existsSync(indexPath)) {
                        console.log('üìÑ Serving fallback index.html');
                        return res.sendFile(indexPath);
                    }
                    // Servir la page 404 Next.js si disponible
                    const notFoundPath = path.join(process.cwd(), 'build', 'server', 'pages', '404.html');
                    if (require('fs').existsSync(notFoundPath)) {
                        console.log('üìÑ Serving Next.js 404.html');
                        return res.status(404).sendFile(notFoundPath);
                    }
                    // Fallback final
                    res.status(404).json({
                        error: 'Page not found',
                        message: 'Cette route n\'existe pas.',
                        path: req.path,
                        timestamp: new Date().toISOString()
                    });
                }
            });
        } else {
            // En d√©veloppement, servir une page d'index ou l'API info
            this.app.get('/{*/any}', (req: Request, res: Response, next) => {
                if (req.path.startsWith('/api/') || 
                    req.path.startsWith('/uploads/') || 
                    req.path.startsWith('/_next/') ||
                    req.path.startsWith('/static/') ||
                    req.path === '/health') {
                    return next();
                }
                
                // Servir l'index.html si la route est '/'
                if (req.path === '/') {
                    const indexPath = path.join(process.cwd(), 'build', 'index.html');
                    if (require('fs').existsSync(indexPath)) {
                        console.log('ÔøΩ Dev mode - serving index.html for:', req.path);
                        return res.sendFile(indexPath);
                    }
                }
                
                console.log(`üîÑ Dev mode - serving API info for: ${req.path}`);
                res.json({
                    message: 'Portfolio API Server - Development Mode',
                    version: '1.0.0',
                    path: req.path,
                    note: 'In production, Next.js would handle this route',
                    endpoints: {
                        auth: '/api/auth',
                        users: '/api/users',
                        projects: '/api/projects',
                        categories: '/api/categories',
                        skills: '/api/skills',
                        experiences: '/api/experiences',
                        educations: '/api/educations',
                        contacts: '/api/contacts',
                        blog: '/api/blog',
                        uploads: '/api/uploads',
                    }
                });
            });
        }
    }

    private initializeErrorHandling(): void {
        // Middleware pour les routes non trouv√©es
        this.app.use(notFound);
        // Middleware global de gestion d'erreurs
        this.app.use(errorHandler);
    }

    public async start(): Promise<void> { 
        try {
            // √âTAPE 1: Pr√©parer Next.js
            await this.initializeNext();
            
            // √âTAPE 2: Connecter √† la base de donn√©es
            await prisma.$connect();
            console.log('‚úÖ Connexion √† la base de donn√©es r√©ussie');

            // √âTAPE 3: Initialiser les middlewares et routes
            this.initializeMiddlewares();
            this.initializeRoutes();
            this.initializeStaticServing();
            this.initializeNextJsHandling();
            this.initializeErrorHandling();

            // √âTAPE 4: D√©marrer le serveur
            this.app.listen(this.port, () => {
                console.log(`üöÄ Serveur Next.js SSR d√©marr√© sur le port ${this.port}`);
                console.log(`üìç Mode: ${process.env.NODE_ENV || 'production'}`);
                console.log(`üåê URL: ${process.env.DOMAIN || 'http://localhost'}:${this.port}`);
                console.log(`üìö Health check: ${process.env.DOMAIN || 'http://localhost'}:${this.port}/health`);
                console.log(`üìÅ Build directory: build/`);
            });
        } catch (error) {
            console.error('‚ùå Impossible de d√©marrer le serveur:', error);
            process.exit(1);
        }
    }

    public getApp(): Application {
        return this.app;
    }
}

// Cr√©ation et d√©marrage du serveur
const server = new Server();

// Gestion gracieuse de l'arr√™t
process.on('SIGINT', async () => {
    await prisma.$disconnect();
    console.log('\nüõë Arr√™t du serveur...');
    process.exit(0);
});

process.on('SIGTERM', () => {
    console.log('\nüõë Arr√™t du serveur...');
    process.exit(0);
});

// D√©marrage du serveur
if (require.main === module) {
    server.start();
}

export default server;
